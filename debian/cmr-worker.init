#!/bin/bash

### BEGIN INIT INFO
# Provides:        cmr-worker
# Required-Start:  $network $remote_fs $syslog
# Required-Stop:   $network $remote_fs $syslog
# Default-Start:   2 3 4 5
# Default-Stop:    0 1 6
# Short-Description: Start Cluster Map Reduce Server
### END INIT INFO

PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/local/sbin
. /lib/lsb/init-functions

if [ "$(id -u)" -ne "0" ]; then
  echo "FATAL: must run as root, exiting.." >&2
  exit 1
fi

RED='\e[1;31m'
GREEN='\e[1;32m'
NC='\e[0m'

ACTION=$1;
NAME="cmr-worker"
NUMINSTANCES=1
PIDBASE=/var/run/cmr
LOGBASE=/var/log/cmr
CONFIG="/etc/cmr/config.ini"

[ -d ${LOGBASE} ] || mkdir -p ${LOGBASE}
[ -d ${PIDBASE} ] || mkdir -p ${PIDBASE}

if [ ! -r ${CONFIG} ]; then
  /bin/echo -e "${RED}Failed to read configration file. Exiting...${NC}" >&2
  exit 1
fi

if [ -r /etc/default/${NAME} ]; then
  . /etc/default/${NAME}
fi

function ok() {
  echo -e " ${GREEN}ok${NC}"
}

function fail() {
  echo -e " ${RED}failed${NC}"
}

get_config() {
  PIDFILE=${PIDBASE}/worker-$1.pid
  LOGFILE=${LOGBASE}/worker-$1.log

  if [ -r ${PIDFILE} ]; then
    PID="$(cat ${PIDFILE})"
  else
    PID=""
  fi
}

function service_start() {
  local RETVAL=-1
  get_config $1
  if service_status; then
    echo -ne " * ${NAME} ($1: ${PID}) is already running" && ok
    RETVAL=0
  else
    echo " * ${NAME} ($1) was not running"
    echo -ne "   - Starting..."
    ${NAME} --config ${CONFIG} \
            --log ${LOGFILE} > /dev/null 2>&1 &

    echo $! > $PIDFILE &

    if service_status; then
      fail
      rm -f ${PIDFILE} 2> /dev/null
      RETVAL=1
    else
      ok
      RETVAL=0
    fi
  fi

  return $RETVAL
}

function service_stop() {
  local RETVAL=-1
  get_config $1
  if service_status; then
    echo " * ${NAME} ($1: ${PID}) is running"
    echo -ne "   - Stopping..."
    kill $(cat $PIDFILE 2> /dev/null)
    rm -f $PIDFILE 2> /dev/null

    if service_status; then
      fail
      RETVAL=1
    else
      ok
      RETVAL=0
    fi
  else
    echo -ne " * ${NAME} ($1) was not running" && ok
    RETVAL=0
  fi

  return $RETVAL
}

function service_restart() {
  local RETVAL=-1
  if service_stop $1; then
    service_start $1
    RETVAL=$?
  else
    RETVAL=1
  fi

  return $RETVAL
}

function service_status() {
  local RETVAL=-1
  if [ ! -r $PIDFILE ]; then
    RETVAL=1
  elif ( kill -0 $(cat $PIDFILE 2> /dev/null) 2> /dev/null ); then
    RETVAL=0
  else
    rm -f $PIDFILE 2> /dev/null
    RETVAL=1
  fi

  return $RETVAL
}

ERROR=0
for thread in $( seq 1 ${NUMINSTANCES} ); do
  case $ACTION in
    start) # start the service
      service_start $thread
      let ERROR+=$?
    ;;
    stop) # stop the service
      service_stop $thread
      let ERROR+=$?
    ;;
    restart) # stop and restart the service if the service is already running, otherwise start the service
      service_restart $thread
      let ERROR+=$?
    ;;
    status) # print the current status of the service
      get_config $thread
      echo -en " * ${NAME} ($thread: ${PID}) is "
      if service_status; then
        echo -en "running" && ok
      else
        echo -en "not running" && fail
      fi
    ;;
    *)
      echo "Usage: $0 {start|stop|restart|status}" >&2
      exit 2
    ;;
  esac
done

RETVAL=0
if [ "${ERROR}" -gt "0" ]; then
  echo ""
  echo "There have been \"$ERROR\" errors"
  RETVAL=1
fi

exit $RETVAL
